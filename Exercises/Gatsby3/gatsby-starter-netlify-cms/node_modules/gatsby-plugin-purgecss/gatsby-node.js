"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.onCreateWebpackConfig = onCreateWebpackConfig;

var _utils = require("./utils");

var _paths = _interopRequireDefault(require("./paths"));

var _shared = require("./shared");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

const loadersRegex = /postcss-loader/;
/**
 * @typedef {object} OptionObject
 * @property {boolean} OptionObject.rejected
 * @property {string[]} OptionObject.content
 * @property {string[]} OptionObject.ignore
 * @property {string[]} OptionObject.purgeOnly
 * @property {boolean} OptionObject.debug
 * @property {boolean} OptionObject.printRejected
 * @property {string[]} OptionObject.whitelist
 * @property {boolean} OptionObject.printAll
 * @property {boolean} OptionObject.tailwind
 * @property {boolean} OptionObject.develop
 * @property {any[]} OptionObject.extractors
 */

function onCreateWebpackConfig({
  actions,
  stage,
  getConfig
}, _ref) {
  var _config$module;

  let {
    plugins
    /** @type OptionObject */

  } = _ref,
      userOptions = _objectWithoutProperties(_ref, ["plugins"]);

  const whitelist = ['html', 'body'];

  if (userOptions.whitelist) {
    userOptions.whitelist = [...whitelist, ...userOptions.whitelist];
  } else {
    userOptions.whitelist = whitelist;
  }

  userOptions = _objectSpread({
    content: [_paths.default.src],
    rejected: true,
    printRejected: false,
    printAll: false,
    debug: false,
    develop: false,
    tailwind: false,
    ignore: [],
    purgeOnly: [],
    extractors: []
  }, userOptions);

  if (userOptions.tailwind) {
    userOptions.defaultExtractor =
    /**
     * @param {string} content
     */
    content => content.match(/[\w-/:]+(?<!:)/g) || [];
  }

  if (userOptions.rejected && stage === 'build-html') {
    _shared.stats.printStats();
  }

  if (stage === 'develop-html' || stage === 'build-html') {
    return;
  } else if (stage === 'develop') {
    if (!userOptions.develop) {
      return;
    }
  }

  const {
    setWebpackConfig
  } = actions;
  /**
   * @type {WebpackConfig}
   */

  const config = getConfig();
  const existingRules = config === null || config === void 0 ? void 0 : (_config$module = config.module) === null || _config$module === void 0 ? void 0 : _config$module.rules;
  /**
   * @type {RuleSetLoader}
   */

  const purgecssloader = {
    loader: _paths.default.loader,
    options: userOptions
  };
  existingRules === null || existingRules === void 0 ? void 0 : existingRules.forEach(rule => {
    if (Array.isArray(rule.oneOf)) {
      rule.oneOf.forEach(rule => {
        if (Array.isArray(rule.use)) {
          const index = (0, _utils.findLoader)(rule.use, loadersRegex);
          (0, _utils.insertLoader)(rule.use, index, purgecssloader);
        }
      });
    }
  });
  actions.replaceWebpackConfig(config);

  if (userOptions.debug) {
    _shared.Debug.writeConfig(getConfig());
  }
}